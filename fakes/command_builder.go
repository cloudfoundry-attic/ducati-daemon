// This file was generated by counterfeiter
package fakes

import (
	"net"
	"sync"

	"github.com/appc/cni/pkg/types"
	"github.com/cloudfoundry-incubator/ducati-daemon/executor"
	"github.com/cloudfoundry-incubator/ducati-daemon/lib/namespace"
)

type CommandBuilder struct {
	IdempotentlyCreateSandboxStub        func(sandboxName, dnsAddress string) executor.Command
	idempotentlyCreateSandboxMutex       sync.RWMutex
	idempotentlyCreateSandboxArgsForCall []struct {
		sandboxName string
		dnsAddress  string
	}
	idempotentlyCreateSandboxReturns struct {
		result1 executor.Command
	}
	IdempotentlyCreateVxlanStub        func(vxlanName string, vni int, sandboxName string, sandboxNS namespace.Namespace) executor.Command
	idempotentlyCreateVxlanMutex       sync.RWMutex
	idempotentlyCreateVxlanArgsForCall []struct {
		vxlanName   string
		vni         int
		sandboxName string
		sandboxNS   namespace.Namespace
	}
	idempotentlyCreateVxlanReturns struct {
		result1 executor.Command
	}
	AddRoutesStub        func(interfaceName string, ipConfig *types.IPConfig) executor.Command
	addRoutesMutex       sync.RWMutex
	addRoutesArgsForCall []struct {
		interfaceName string
		ipConfig      *types.IPConfig
	}
	addRoutesReturns struct {
		result1 executor.Command
	}
	SetupVethStub        func(containerNS namespace.Namespace, sandboxLinkName string, containerLinkName string, address net.IPNet, sandboxNS namespace.Namespace, routeCommand executor.Command) executor.Command
	setupVethMutex       sync.RWMutex
	setupVethArgsForCall []struct {
		containerNS       namespace.Namespace
		sandboxLinkName   string
		containerLinkName string
		address           net.IPNet
		sandboxNS         namespace.Namespace
		routeCommand      executor.Command
	}
	setupVethReturns struct {
		result1 executor.Command
	}
	IdempotentlySetupBridgeStub        func(vxlanName, sandboxLinkName, bridgeName string, sandboxNS namespace.Namespace, ipamResult *types.Result) executor.Command
	idempotentlySetupBridgeMutex       sync.RWMutex
	idempotentlySetupBridgeArgsForCall []struct {
		vxlanName       string
		sandboxLinkName string
		bridgeName      string
		sandboxNS       namespace.Namespace
		ipamResult      *types.Result
	}
	idempotentlySetupBridgeReturns struct {
		result1 executor.Command
	}
}

func (fake *CommandBuilder) IdempotentlyCreateSandbox(sandboxName string, dnsAddress string) executor.Command {
	fake.idempotentlyCreateSandboxMutex.Lock()
	fake.idempotentlyCreateSandboxArgsForCall = append(fake.idempotentlyCreateSandboxArgsForCall, struct {
		sandboxName string
		dnsAddress  string
	}{sandboxName, dnsAddress})
	fake.idempotentlyCreateSandboxMutex.Unlock()
	if fake.IdempotentlyCreateSandboxStub != nil {
		return fake.IdempotentlyCreateSandboxStub(sandboxName, dnsAddress)
	} else {
		return fake.idempotentlyCreateSandboxReturns.result1
	}
}

func (fake *CommandBuilder) IdempotentlyCreateSandboxCallCount() int {
	fake.idempotentlyCreateSandboxMutex.RLock()
	defer fake.idempotentlyCreateSandboxMutex.RUnlock()
	return len(fake.idempotentlyCreateSandboxArgsForCall)
}

func (fake *CommandBuilder) IdempotentlyCreateSandboxArgsForCall(i int) (string, string) {
	fake.idempotentlyCreateSandboxMutex.RLock()
	defer fake.idempotentlyCreateSandboxMutex.RUnlock()
	return fake.idempotentlyCreateSandboxArgsForCall[i].sandboxName, fake.idempotentlyCreateSandboxArgsForCall[i].dnsAddress
}

func (fake *CommandBuilder) IdempotentlyCreateSandboxReturns(result1 executor.Command) {
	fake.IdempotentlyCreateSandboxStub = nil
	fake.idempotentlyCreateSandboxReturns = struct {
		result1 executor.Command
	}{result1}
}

func (fake *CommandBuilder) IdempotentlyCreateVxlan(vxlanName string, vni int, sandboxName string, sandboxNS namespace.Namespace) executor.Command {
	fake.idempotentlyCreateVxlanMutex.Lock()
	fake.idempotentlyCreateVxlanArgsForCall = append(fake.idempotentlyCreateVxlanArgsForCall, struct {
		vxlanName   string
		vni         int
		sandboxName string
		sandboxNS   namespace.Namespace
	}{vxlanName, vni, sandboxName, sandboxNS})
	fake.idempotentlyCreateVxlanMutex.Unlock()
	if fake.IdempotentlyCreateVxlanStub != nil {
		return fake.IdempotentlyCreateVxlanStub(vxlanName, vni, sandboxName, sandboxNS)
	} else {
		return fake.idempotentlyCreateVxlanReturns.result1
	}
}

func (fake *CommandBuilder) IdempotentlyCreateVxlanCallCount() int {
	fake.idempotentlyCreateVxlanMutex.RLock()
	defer fake.idempotentlyCreateVxlanMutex.RUnlock()
	return len(fake.idempotentlyCreateVxlanArgsForCall)
}

func (fake *CommandBuilder) IdempotentlyCreateVxlanArgsForCall(i int) (string, int, string, namespace.Namespace) {
	fake.idempotentlyCreateVxlanMutex.RLock()
	defer fake.idempotentlyCreateVxlanMutex.RUnlock()
	return fake.idempotentlyCreateVxlanArgsForCall[i].vxlanName, fake.idempotentlyCreateVxlanArgsForCall[i].vni, fake.idempotentlyCreateVxlanArgsForCall[i].sandboxName, fake.idempotentlyCreateVxlanArgsForCall[i].sandboxNS
}

func (fake *CommandBuilder) IdempotentlyCreateVxlanReturns(result1 executor.Command) {
	fake.IdempotentlyCreateVxlanStub = nil
	fake.idempotentlyCreateVxlanReturns = struct {
		result1 executor.Command
	}{result1}
}

func (fake *CommandBuilder) AddRoutes(interfaceName string, ipConfig *types.IPConfig) executor.Command {
	fake.addRoutesMutex.Lock()
	fake.addRoutesArgsForCall = append(fake.addRoutesArgsForCall, struct {
		interfaceName string
		ipConfig      *types.IPConfig
	}{interfaceName, ipConfig})
	fake.addRoutesMutex.Unlock()
	if fake.AddRoutesStub != nil {
		return fake.AddRoutesStub(interfaceName, ipConfig)
	} else {
		return fake.addRoutesReturns.result1
	}
}

func (fake *CommandBuilder) AddRoutesCallCount() int {
	fake.addRoutesMutex.RLock()
	defer fake.addRoutesMutex.RUnlock()
	return len(fake.addRoutesArgsForCall)
}

func (fake *CommandBuilder) AddRoutesArgsForCall(i int) (string, *types.IPConfig) {
	fake.addRoutesMutex.RLock()
	defer fake.addRoutesMutex.RUnlock()
	return fake.addRoutesArgsForCall[i].interfaceName, fake.addRoutesArgsForCall[i].ipConfig
}

func (fake *CommandBuilder) AddRoutesReturns(result1 executor.Command) {
	fake.AddRoutesStub = nil
	fake.addRoutesReturns = struct {
		result1 executor.Command
	}{result1}
}

func (fake *CommandBuilder) SetupVeth(containerNS namespace.Namespace, sandboxLinkName string, containerLinkName string, address net.IPNet, sandboxNS namespace.Namespace, routeCommand executor.Command) executor.Command {
	fake.setupVethMutex.Lock()
	fake.setupVethArgsForCall = append(fake.setupVethArgsForCall, struct {
		containerNS       namespace.Namespace
		sandboxLinkName   string
		containerLinkName string
		address           net.IPNet
		sandboxNS         namespace.Namespace
		routeCommand      executor.Command
	}{containerNS, sandboxLinkName, containerLinkName, address, sandboxNS, routeCommand})
	fake.setupVethMutex.Unlock()
	if fake.SetupVethStub != nil {
		return fake.SetupVethStub(containerNS, sandboxLinkName, containerLinkName, address, sandboxNS, routeCommand)
	} else {
		return fake.setupVethReturns.result1
	}
}

func (fake *CommandBuilder) SetupVethCallCount() int {
	fake.setupVethMutex.RLock()
	defer fake.setupVethMutex.RUnlock()
	return len(fake.setupVethArgsForCall)
}

func (fake *CommandBuilder) SetupVethArgsForCall(i int) (namespace.Namespace, string, string, net.IPNet, namespace.Namespace, executor.Command) {
	fake.setupVethMutex.RLock()
	defer fake.setupVethMutex.RUnlock()
	return fake.setupVethArgsForCall[i].containerNS, fake.setupVethArgsForCall[i].sandboxLinkName, fake.setupVethArgsForCall[i].containerLinkName, fake.setupVethArgsForCall[i].address, fake.setupVethArgsForCall[i].sandboxNS, fake.setupVethArgsForCall[i].routeCommand
}

func (fake *CommandBuilder) SetupVethReturns(result1 executor.Command) {
	fake.SetupVethStub = nil
	fake.setupVethReturns = struct {
		result1 executor.Command
	}{result1}
}

func (fake *CommandBuilder) IdempotentlySetupBridge(vxlanName string, sandboxLinkName string, bridgeName string, sandboxNS namespace.Namespace, ipamResult *types.Result) executor.Command {
	fake.idempotentlySetupBridgeMutex.Lock()
	fake.idempotentlySetupBridgeArgsForCall = append(fake.idempotentlySetupBridgeArgsForCall, struct {
		vxlanName       string
		sandboxLinkName string
		bridgeName      string
		sandboxNS       namespace.Namespace
		ipamResult      *types.Result
	}{vxlanName, sandboxLinkName, bridgeName, sandboxNS, ipamResult})
	fake.idempotentlySetupBridgeMutex.Unlock()
	if fake.IdempotentlySetupBridgeStub != nil {
		return fake.IdempotentlySetupBridgeStub(vxlanName, sandboxLinkName, bridgeName, sandboxNS, ipamResult)
	} else {
		return fake.idempotentlySetupBridgeReturns.result1
	}
}

func (fake *CommandBuilder) IdempotentlySetupBridgeCallCount() int {
	fake.idempotentlySetupBridgeMutex.RLock()
	defer fake.idempotentlySetupBridgeMutex.RUnlock()
	return len(fake.idempotentlySetupBridgeArgsForCall)
}

func (fake *CommandBuilder) IdempotentlySetupBridgeArgsForCall(i int) (string, string, string, namespace.Namespace, *types.Result) {
	fake.idempotentlySetupBridgeMutex.RLock()
	defer fake.idempotentlySetupBridgeMutex.RUnlock()
	return fake.idempotentlySetupBridgeArgsForCall[i].vxlanName, fake.idempotentlySetupBridgeArgsForCall[i].sandboxLinkName, fake.idempotentlySetupBridgeArgsForCall[i].bridgeName, fake.idempotentlySetupBridgeArgsForCall[i].sandboxNS, fake.idempotentlySetupBridgeArgsForCall[i].ipamResult
}

func (fake *CommandBuilder) IdempotentlySetupBridgeReturns(result1 executor.Command) {
	fake.IdempotentlySetupBridgeStub = nil
	fake.idempotentlySetupBridgeReturns = struct {
		result1 executor.Command
	}{result1}
}
