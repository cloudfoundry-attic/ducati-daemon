// This file was generated by counterfeiter
package fakes

import (
	"sync"

	"github.com/cloudfoundry-incubator/ducati-daemon/executor"
	"github.com/cloudfoundry-incubator/ducati-daemon/lib/namespace"
)

type Context struct {
	AddressManagerStub        func() executor.AddressManager
	addressManagerMutex       sync.RWMutex
	addressManagerArgsForCall []struct{}
	addressManagerReturns     struct {
		result1 executor.AddressManager
	}
	LinkFactoryStub        func() executor.LinkFactory
	linkFactoryMutex       sync.RWMutex
	linkFactoryArgsForCall []struct{}
	linkFactoryReturns     struct {
		result1 executor.LinkFactory
	}
	RouteManagerStub        func() executor.RouteManager
	routeManagerMutex       sync.RWMutex
	routeManagerArgsForCall []struct{}
	routeManagerReturns     struct {
		result1 executor.RouteManager
	}
	SandboxRepositoryStub        func() namespace.Repository
	sandboxRepositoryMutex       sync.RWMutex
	sandboxRepositoryArgsForCall []struct{}
	sandboxRepositoryReturns     struct {
		result1 namespace.Repository
	}
}

func (fake *Context) AddressManager() executor.AddressManager {
	fake.addressManagerMutex.Lock()
	fake.addressManagerArgsForCall = append(fake.addressManagerArgsForCall, struct{}{})
	fake.addressManagerMutex.Unlock()
	if fake.AddressManagerStub != nil {
		return fake.AddressManagerStub()
	} else {
		return fake.addressManagerReturns.result1
	}
}

func (fake *Context) AddressManagerCallCount() int {
	fake.addressManagerMutex.RLock()
	defer fake.addressManagerMutex.RUnlock()
	return len(fake.addressManagerArgsForCall)
}

func (fake *Context) AddressManagerReturns(result1 executor.AddressManager) {
	fake.AddressManagerStub = nil
	fake.addressManagerReturns = struct {
		result1 executor.AddressManager
	}{result1}
}

func (fake *Context) LinkFactory() executor.LinkFactory {
	fake.linkFactoryMutex.Lock()
	fake.linkFactoryArgsForCall = append(fake.linkFactoryArgsForCall, struct{}{})
	fake.linkFactoryMutex.Unlock()
	if fake.LinkFactoryStub != nil {
		return fake.LinkFactoryStub()
	} else {
		return fake.linkFactoryReturns.result1
	}
}

func (fake *Context) LinkFactoryCallCount() int {
	fake.linkFactoryMutex.RLock()
	defer fake.linkFactoryMutex.RUnlock()
	return len(fake.linkFactoryArgsForCall)
}

func (fake *Context) LinkFactoryReturns(result1 executor.LinkFactory) {
	fake.LinkFactoryStub = nil
	fake.linkFactoryReturns = struct {
		result1 executor.LinkFactory
	}{result1}
}

func (fake *Context) RouteManager() executor.RouteManager {
	fake.routeManagerMutex.Lock()
	fake.routeManagerArgsForCall = append(fake.routeManagerArgsForCall, struct{}{})
	fake.routeManagerMutex.Unlock()
	if fake.RouteManagerStub != nil {
		return fake.RouteManagerStub()
	} else {
		return fake.routeManagerReturns.result1
	}
}

func (fake *Context) RouteManagerCallCount() int {
	fake.routeManagerMutex.RLock()
	defer fake.routeManagerMutex.RUnlock()
	return len(fake.routeManagerArgsForCall)
}

func (fake *Context) RouteManagerReturns(result1 executor.RouteManager) {
	fake.RouteManagerStub = nil
	fake.routeManagerReturns = struct {
		result1 executor.RouteManager
	}{result1}
}

func (fake *Context) SandboxRepository() namespace.Repository {
	fake.sandboxRepositoryMutex.Lock()
	fake.sandboxRepositoryArgsForCall = append(fake.sandboxRepositoryArgsForCall, struct{}{})
	fake.sandboxRepositoryMutex.Unlock()
	if fake.SandboxRepositoryStub != nil {
		return fake.SandboxRepositoryStub()
	} else {
		return fake.sandboxRepositoryReturns.result1
	}
}

func (fake *Context) SandboxRepositoryCallCount() int {
	fake.sandboxRepositoryMutex.RLock()
	defer fake.sandboxRepositoryMutex.RUnlock()
	return len(fake.sandboxRepositoryArgsForCall)
}

func (fake *Context) SandboxRepositoryReturns(result1 namespace.Repository) {
	fake.SandboxRepositoryStub = nil
	fake.sandboxRepositoryReturns = struct {
		result1 namespace.Repository
	}{result1}
}

var _ executor.Context = new(Context)
